\documentclass[preprint]{sigplanconf}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{stmaryrd}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{lstcoq}

\lstset{ %
  numberbychapter=false, %
  language=coq, %
%%  frame=lines, %
  frameshape={yyy}{n}{n}{yyy}, %
  framexleftmargin=-3pt,
  framexrightmargin=-3pt,
  numberstyle=\tiny, %
  basicstyle=\footnotesize, %
  captionpos=b,
  numbersep=5pt,
  xleftmargin=5pt,
  xrightmargin=5pt}

\usepackage[bookmarks=true,colorlinks=true, linkcolor=MidnightBlue, citecolor=cyan]{hyperref}

\newcommand{\FOR}{{\tt for} \ }
\newcommand{\FORALL}{{\tt forall} \ }
\newcommand{\EXISTS}{{\tt exists} \ }
\newcommand{\WHERE}{{\tt where} \ }
\newcommand{\IN}{ \ {\tt in} \ }
\newcommand{\RETURN}{{\tt return} \ }
\newcommand{\DO}{{\tt do}}
\newcommand{\IF}{{\tt if} \ }
\newcommand{\THEN}{{\tt then} \ }
\newcommand{\ELSE}{{\tt else} \ }
\newcommand{\ZERO}{{\tt zero}}
\newcommand{\FALSE}{{\tt false}}
\newcommand{\BIND}{{\tt bind}}
\newcommand{\UNION}{{\tt union}}
\newcommand{\MAP}{{\tt map}}
\newcommand{\CONS}{{\tt Cons}}
\newcommand{\NIL}{{\tt Nil}}

\newcommand{\greg}[1]{\textcolor{blue}{GREG: #1}}
\newcommand{\ltac}[0]{\ensuremath{\mathcal{L}_{\mathrm{tac}}}}

\begin{document}

\title{Using Dependent Types and Tactics to Enable Semantic Optimization of Language-Integrated Queries}

\authorinfo{Gregory Malecha}{University of California at San Diego}{\sf gmalecha@eng.ucsd.edu} 

\authorinfo{Ryan Wisnesky\titlenote{Work supported by ONR grant N000141310260 and AFOSR grant FA9550-14-1-0031}}{Massachusetts Institute of Technology}{\sf wisnesky@math.mit.edu}

\date{\today}

\maketitle
%\vspace*{-.3in}
\begin{abstract}
Semantic optimization -- the use of data integrity constraints to optimize relational queries -- has been well studied but, owing to limitations in how SQL handles constraints, has not often been applied by mainstream RDBMSs. In a language-integrated query setting, however, the query provider is free to rewrite queries before they are executed on an RDBMS.  We show, using Coq as our ambient language, how to use dependent types to represent a well known class of constraints -- embedded, implicational dependencies -- and how Coq tactics can be used to implement a particular kind of semantic optimization: tableaux minimization, which minimizes the number of joins required by a query.
\end{abstract}

\section{Introduction}

{\it Semantic optimization}~\cite{foundations,Deutsch:2006:QRC:1121995.1122010,Popa99anequational} is the 
use of data integrity constraints such as keys, functional dependencies, inclusions, and join decompositions to optimize relational queries. For example~\cite{foundations}, consider the following contrived query over a relation (set of records) $Movies$ 
with fields ${\sf title}$, ${\sf director}$, and ${\sf actor}$:
\begin{eqnarray*}
& & \FOR (m_1 \IN Movies) \ (m_2 \IN Movies) \\
 & & \WHERE m_1.{\sf title} = m_2.{\sf title} \\
 & & \RETURN (m_1.{\sf director}, m_2.{\sf actor})
\end{eqnarray*}        
This query returns (a set of) tuples $(d,a)$ where $a$ acted in a movie directed by $d
$.  A naive implementation of this query will require a join.  However, when $Movies$ 
satisfies the the functional dependency ${\sf title} \to {\sf director}$ (meaning that 
if $({\sf director}: d, {\sf title}: t, {\sf actor}: a)$ and $({\sf director}: d^\prime, {\sf title}: t^\prime, {\sf actor}: a^\prime)$ are $Movies$ records such that $t = t^\prime$, then $d = d^\prime$), this query is equivalent to:
\begin{eqnarray*}
& & \FOR (m \IN Movies) \\
 & & \RETURN (m.{\sf director}, m.{\sf actor})
 \end{eqnarray*}
which can be evaluated without a join.  (Note that if $Movies$ did not satisfy the functional dependency, the equivalence would not necessarily hold.)  

Of course, knowing that the functional dependency holds, a programmer might simply write the optimized query to begin with.  But constraints are not always known at compile time, such as when relations are indexed dynamically.  Moreover, people are not always the programmers: information-integration systems such as Clio~\cite{haas:clio} automatically generate large numbers of queries.  The significant, potentially order-of-magnitude speed-ups enabled by semantic optimization are well-documented in the literature~\cite{Cheng:1999:ITS:645925.671357}.  

Although certain RDBMS's such as DB2 can perform limited amounts of semantic optimization~\cite{Cheng:1999:ITS:645925.671357}, RDBMS's are fundamentally limited by the expressiveness of SQL as a constraint specification language: SQL includes keys and foreign keys but constraints such as the functional dependency above are not directly expressible in SQL.  (Technically, functional dependencies can be encoded as {\tt CHECK} constraints, but even {\tt CHECK} constraints cannot capture multi-table constraints such as join decompositions).  In relational database theory, a fragment of first-order logic, the so-called {\it embedded, implicational dependencies} (EDs), are used to capture almost all constraints used in practice, including keys, foreign keys, inclusions, functional dependencies, and join decompositions, and a large body of literature has developed to facilitate reasoning about queries in the presence of EDs~\cite{Popa99anequational}. 

{\bf Contributions and Outline.} In this paper we demonstrate that dependently-typed language-integrated query systems (LINQs~\cite{monad}) that compile to SQL can expose data integrity constraints, in the guise of EDs, as first-class objects to their users, and that they can apply sophisticated semantic optimization techniques before translating user queries into SQL.  In particular, we show, using Coq~\cite{coq:coq} as our ambient language, how to use dependent equality types to represent EDs, and how to use Coq tactics to implement a particular kind of semantic optimization: tableaux minimization, which minimizes the number of joins required by a query.  This paper is divided into two parts: the first part is a tutorial on tableaux minimization, and the second part is a Coq rendering of the first part. The Coq development is available at {\sf github.com/gmalecha/semantic-query}.

{\bf Related Work.} Most theoretical work on language-integrated query systems is done in a simply-typed setting~\cite{tannen:1992:NEQ:645500.655920}.  In practice, however, sophisticated type systems are often used to to facilitate the embedding of a query sublanguage into a general purpose programming language.  For example, labelled row types~\cite{mpj:jones1996a} can be used to embed DBMS records into a programming language, and the Opaleye library for Haskell uses the Arrow type-class to statically enforce the wellformedness of its SQL output~\cite{opaleye}.  Rarer still are dependently-typed embedded query languages: although Coq has been used to prove the correctness of certain database-related languages, data structures, and algorithms~\cite{DBLP:conf/popl/DelawarePGC15}~\cite{Malecha:2010:TVR:1706299.1706329}~\cite{coqdb}, none of this work is concerned with using Coq directly as an embedded query language as we are doing in this paper (i.e., these works use deep embeddings of query languages, whereas we use a shallow embedding).  

\section{Queries}
%For ease of exposition, in the first part of this paper we will assume we are working in a strongly-normalizing typed $\lambda$-calculus with first-class records, such as~\cite{mpj:jones1996a}.

In this paper we will focus on relational {\it conjunctive queries}~\cite{foundations}, and for the first part of this paper the specifics of our query language will not matter.   We will write $(l_1: e_1, \ldots, l_N: e_N)$ to indicate a record with unique labels $l_1, \ldots l_N$ formed from expressions $e_1, \ldots, e_N$, where an expression has the form $v.l$ for a variable $v$ and label $l$.  We will abbreviate (potentially 0-length) vectors of variables $x_1,...,x_N$ as $\overrightarrow{x}$.  We will write $P(\overrightarrow{x})$ to indicate a conjunction of equalities over expressions over variables $\overrightarrow{x}$.  Assumed base relations (often called {\it roots}) will be written in capital letters, such as $\overrightarrow{X}$.  A {\it tableau} has the form:
\begin{normalsize}
\begin{eqnarray*}
 & & \FOR \overrightarrow{(x \IN X)} \\
 & & \WHERE P(\overrightarrow{x})
\end{eqnarray*}
\end{normalsize}
The $\overrightarrow{(x \IN X)}$ are called {\it generators}.  A (conjunctive) {\it query} is a pair of a  tableau and a record (``return clause'') $R(\overrightarrow{x})$:
\begin{normalsize}
\begin{eqnarray*}
 & & \FOR \overrightarrow{(x \IN X)} \\
& & \WHERE  P(\overrightarrow{x}) \\ 
 & & \RETURN R(\overrightarrow{x})
\end{eqnarray*}
\end{normalsize}
{\bf Extensions.} We will only consider relational conjunctive queries in this paper, but many extensions to conjunctive queries have been studied in the literature~\cite{foundations}.  Two extensions are particularly important, because many results about semantic optimization, including tableaux minimization, hold for these extensions~\cite{Popa99anequational}:
\begin{itemize} 
\item  It is possible to allow generators to be dependent, thereby allowing, for example, nested relations~\cite{Popa99anequational}:
\begin{normalsize}
$$ \FOR (g \IN Groups) \ (person \IN g) \ \ldots $$
\end{normalsize}
\item It is possible to interpret queries in arbitrary {\it monads with zeroes}, for example, the list monad or the bag monad.  However, the  optimization procedure described in this paper is only sound for monads that are commutative and idempotent~\cite{Popa99anequational}:
$$
\FOR (x \IN X)(y \IN Y)  \cong \FOR (y \IN Y) (x \IN X) 
$$
$$
\FOR (x \IN X) \cong \FOR (x \IN X)(x' \IN X) 
$$
Such monads arise, for example, as power monads on topoi~\cite{BW}.  It is also possible to interpret queries in {\it monad algebras}~\cite{755736}.  For example, it is possible to write a query to find the largest element of a set: 
\begin{normalsize}
$$ \FOR (x \IN SomeSetOfInts) \ {\tt max} \ x $$
\end{normalsize}

\end{itemize}

\section{Embedded Dependencies}

An {\it embedded dependency (ED)}~\cite{foundations} is a pair of tableaux, where one tableau is universally quantified, and the other existentially:
\begin{normalsize}
\begin{eqnarray*}
C & := & \FORALL \overrightarrow{(x \IN X)} \\
 & & \WHERE P(\overrightarrow{x}) \\
 & & \EXISTS \overrightarrow{(y \IN Y)} \\
 & & \WHERE B(\overrightarrow{x}, \overrightarrow{y})
\end{eqnarray*}
\end{normalsize}
{\bf Example.} The functional dependency from our example from the introduction is written (the \EXISTS clause is empty):
\begin{normalsize}
\begin{eqnarray*}
& & \FORALL (x \IN Movies) \ (y \IN Movies) \\
& & \WHERE x.{\sf title} = y.{\sf title}, \\ 
& & \EXISTS \\
& & \WHERE x.{\sf director} = y.{\sf director}
\end{eqnarray*}
\end{normalsize}
An ED $C$ gives rise to two conjunctive queries, the {\it front} and {\it back} of $C$.  We write $\mathcal{L}
(\overrightarrow{x})$ to indicate a record capturing the variables $\overrightarrow{x}
$; e.g., $({\sf x_1}: x_1, \ldots ,{\sf x_N}: x_N)$.  %The front of an ED is:
\begin{normalsize}
\begin{eqnarray*}
front(C)& := & \FOR \overrightarrow{(x \IN X)} \\ 
& & \WHERE P(\overrightarrow{x}) \\
& & \RETURN \mathcal{L}(\overrightarrow{x})  \\
& & \\
%\end{eqnarray*}
%\end{normalsize}
%and the back is
%\begin{normalsize}
%\begin{eqnarray*}
back(C) & := & \FOR \overrightarrow{(x \IN X)} \ \overrightarrow{(y \IN Y)} \\ 
& & \WHERE P(\overrightarrow{x}) \wedge B(\overrightarrow{x}, \overrightarrow{y}) \\
& & \RETURN \mathcal{L}(\overrightarrow{x})
\end{eqnarray*}
\end{normalsize}
It is easy to establish~\cite{Popa99anequational} that for every $I$,
$$I \models C \ \ \ \ \textnormal{iff} \ \ \ \  front(C)(I) = back(C)(I)$$
In fact, in the second half of this paper, we will use a dependent equality type corresponding to the above equation as a type of proofs that an ED holds in a particular instance.

{\bf Notation.}  When two queries $Q_1$ and $Q_2$ give the same result on every instance, we write $Q_1 \cong Q_2$.  When $Q_1$ and $Q_2$ give the same result on every instance satisfying some set of EDs $C$, we write $C \vdash Q_1 \cong Q_2$.


%
%In the set monad, the above definition of satisfaction corresponds to our intuitive notion of satisfaction; however, this definition of satisfaction has the advantage of being definable for every monad with zero. 
%
%Continuing with our example, our functional dependency holds of a particular instance $Movies$ when
%\begin{normalsize}
%\begin{eqnarray*}
%& & \FOR (x \IN Movies) \ (y \IN Movies) \\
%& & \WHERE x.{\sf title} = y.{\sf title}, \\ 
%& & \RETURN ({\sf x}: x, {\sf y}: y) \\
%& = &  \\
%& & \FOR (x \IN Movies) \ (y \IN Movies) \\
%& & \WHERE x.{\sf title} = y.{\sf title} \wedge x.{\sf director} = y.{\sf director} \\ 
%& & \RETURN ({\sf x}: x, {\sf y}: y) 
%\end{eqnarray*}
%\end{normalsize}
%\noindent
%For example, in this instance:
%\begin{normalsize}
%\begin{eqnarray*}
%{\sf title} & {\sf director} & {\sf actor} \\
%T & D & A \\ 
%T & D & B
%\end{eqnarray*}
%\end{normalsize}
%%\vspace{-.4in}
%\noindent
%the constraint holds because both sides evaluate to (omitting some labels to 
%save space):
%\begin{normalsize}
%\begin{eqnarray*}
%{\sf x} & {\sf y} &  \\
%(T, D, A) & (T, D, A) & \\ 
%(T, D, A) & (T, D, B) & \\ 
%(T, D, B) & (T, D, A) & \\ 
%(T, D, B) & (T, D, B) & 
%\end{eqnarray*}
%\end{normalsize}
%\noindent
%whereas in this instance:
%\begin{normalsize}
%\begin{eqnarray*}
%{\sf title} & {\sf director} & {\sf actor} \\ 
%T & D_1 & A \\ 
%T & D_2 & B
%\end{eqnarray*}
%\end{normalsize}
%\noindent
%the constraint does not hold because the left-hand side and right-hand side evaluate to, respectively:
%\begin{normalsize}
%
%\parbox{3in}{
%\begin{eqnarray*}
%{\sf x} & {\sf y} &  \\
%(T, D_1, A) & (T, D_1, A) &    \\ 
%(T, D_1, A) & (T, D_2, B) &  \\ 
%(T, D_2, B) & (T, D_1, A) & \\ 
%(T, D_2, B) & (T, D_2, B) & 
%\end{eqnarray*}
%}
%\parbox{3in}{
%\begin{eqnarray*}
%{\sf x} & {\sf y} &  \\
% (T, D_1, A) & (T, D_1, A) & \\ 
% (T, D_2, B) & (T, D_2, B) & \\ 
%\end{eqnarray*}
%}
%
%\end{normalsize}
%

\section{Homomorphisms}

A {\it homomorphism} between queries, $h : Q_1 \to Q_2$ 
\begin{normalsize}
\begin{eqnarray*}
Q_1 & := & \FOR \overrightarrow{(v_1 \IN V_1)} \\
          & & \WHERE P_1(\overrightarrow{v_1}) \\
          & & \RETURN R_1(\overrightarrow{v_1}) \\
\to_h & & \\        
Q_2 & := & \FOR \overrightarrow{(v_2 \IN V_2)} \\
          & & \WHERE P_2(\overrightarrow{v_2}) \\
          & & \RETURN R_2(\overrightarrow{v_2})
\end{eqnarray*}
\end{normalsize}
is a substitution mapping the $\FOR$-bound variables of $Q_1$ (namely, $
\overrightarrow{v_1}$) to the $\FOR$-bound variables of $Q_2$ (namely, $
\overrightarrow{v_2}$) that preserves the structure of $Q_1$ in the sense that
\begin{itemize}
\item  
 $(h(v_{1_i}) \IN V_{1_i})$ $ \in$ $\overrightarrow{(v_2 \IN V_2)}$ (that is, the image of each generator in $Q_1$ is found in the generators of $Q_2$). 

\item $P_2(\overrightarrow{v_2})$ $\vdash$ $P_1(h(\overrightarrow{v_1}))$  (that is, the image of the where clause of $Q_1$ is entailed by the where clause of $Q_2$).

\item $P_2$ $\vdash$ $R_1(h(\overrightarrow{v_1})) = R_2(\overrightarrow{v_2})$ (that is, the image of the return clause of $Q_1$ is equal, under $P_2$, to the return clause of $Q_2$).
\end{itemize}
A homomorphism of tableaux is defined the same way, except that the condition about $\RETURN$ clauses is dropped.  

{\bf Notation.} We write $Q_1 \leftrightarrow Q_2$ to mean that there exists homomorphisms $Q_1 \to Q_2$ and $Q_2 \to Q_1$ and we say that $Q_1$ and $Q_2$ are {\it homomorphically equivalent}.  The existence of a homomorphism $Q_1 \to Q_2$ implies that for every $I$, $Q_2(I) \subseteq Q_1(I)$, and vice versa~\cite{foundations}.  Hence $Q_1 \cong Q_2$ iff $Q_1 \leftrightarrow Q_2$.

{\bf Example.} Consider our $Movies$ query 
%When queries are {\it path-conjunctive}---that is, when $P_1$, $P_2$ are conjunctions of equalities between paths of the form $v.l_1,.\ldots l_n, $ and  $R_1$ and $R_2$ are records built from paths, as we are assuming in this paper, finding homomorphisms is NP-hard.  Moreover, in this case there are practical, sound heuristics~\cite{Deutsch:2006:QRC:1121995.1122010} based on pruning the search space of substitutions to remove candidates that are ``obviously wrong'' based on a partial variable assignment. 
\begin{normalsize}
\begin{eqnarray*}
Q_1 & := & \FOR (m_1 \IN Movies) \ (m_2 \IN Movies) \\
 & & \WHERE m_1.{\sf title} = m_2.{\sf title} \\
 & & \RETURN (m_1.{\sf director}, m_2.{\sf actor})
\end{eqnarray*}   
\end{normalsize}
and the semantically optimized query:
\begin{normalsize}
\begin{eqnarray*}
Q_2 & := & \FOR (m \IN Movies) \\
 & & \RETURN (m.{\sf director}, m.{\sf actor})
\end{eqnarray*}   
\end{normalsize}
It is easy to see that for every $I$, $Q_2(I) \subseteq Q_1(I)$, and indeed there is a homomorphism $h : Q_1 \to Q_2$; namely, the substitution $m_1 \mapsto m, m_2 \mapsto m$.  To check this, we first apply $h$ to $Q_1$:
\begin{normalsize}
\begin{eqnarray*}
h(Q_1) & := & \FOR (m \IN Movies) \ (m \IN Movies) \\
 & & \WHERE m.{\sf title} = m.{\sf title} \\
 & & \RETURN (m.{\sf director}, m.{\sf actor})
\end{eqnarray*}   
\end{normalsize}
In $h(Q_1)$ each generator $(m \IN Movies)$ appears in $Q_2$.  Moreover, the ${\tt where}$ 
clause of $h(Q_1)$ is a tautology and hence is entailed by the (empty) ${\tt where}$ clause of 
$Q_2$.  Finally, the two ${\tt return}$ clauses are equal.  As such, the substitution $m_1 
\mapsto m, m_2 \mapsto m$ is a homomorphism.  

There is no homomorphism $Q_2 \to Q_1$, and hence $Q_1 \ncong Q_2$.  
There are only two candidates: $m \mapsto m_1$ and $m \mapsto m_2$.  
Neither works because neither of the  images of $Q_2$'s $\RETURN$ clause (neither 
$\RETURN (m_1.{\sf director}, m_1.{\sf actor})$ nor $\RETURN (m_2.{\sf director},$ $m_2.
{\sf actor})$) is equivalent to $Q_1$'s $\RETURN$ clause ($\RETURN (m_1.{\sf director},$ 
$m_2.{\sf actor})$), even under the equality in $Q_1$ ($m_1.{\sf title} = m_2.{\sf 
title}$). 

%  Indeed, consider the instance:  
%\begin{normalsize}
%\begin{eqnarray*}
%{\sf title} & {\sf director} & {\sf actor} \\ 
%T & D_1 & A \\ 
%T & D_2 & B
%\end{eqnarray*}
%\end{normalsize}
%$Q_1$ and $Q_2$ evaluate to, respectively
%
%\parbox{3in}{
%\begin{normalsize}
%\begin{eqnarray*}
% & {\sf director} & {\sf actor} \\ 
%& D_1 & A \\ 
%& D_1 & B \\
%& D_2 & A \\
%& D_2 & B
%\end{eqnarray*}
%\end{normalsize}
%} \ \ \ \ \parbox{3in}{
%\begin{normalsize}
%\begin{eqnarray*}
% & {\sf director} & {\sf actor} \\ 
%& D_1 & A \\ 
%& D_2 & B
%\end{eqnarray*}
%\end{normalsize}
%}
%
%Of course, if we had chosen an instance $I$ that satisfied the functional dependency {\sf Title} $\to$ {\sf Director}, then $Q_1(I)$ and $Q_2(I)$ would have evaluated to the same result.


\section{The Chase}
%\label{sec:chase}

The chase is a confluent rewriting procedure that rewrites queries using EDs~\cite{foundations}.   Let

 %We now describe the chase, and in the next section we show how to use it to optimize queries.   
\parbox{1.5in}{
\begin{eqnarray*}
 C & := & \FORALL \overrightarrow{(x \IN X)} \\
 & & \WHERE P(\overrightarrow{x}) \\
 & & \EXISTS \overrightarrow{(y \IN Y)} \\
 & & \WHERE B(\overrightarrow{x}, \overrightarrow{y})
\end{eqnarray*}
} \ \ \ \ \ \parbox{1.5in}{
\begin{eqnarray*}
Q & := & \FOR \overrightarrow{(v \IN V)} \\
 & & \WHERE  O(\overrightarrow{v}) \\ 
 & & \RETURN R(\overrightarrow{v})
\end{eqnarray*}
}
and suppose there exists a (tableau) homomorphism $h : front(C) \to Q$.  A {\it chase step} is to rewrite $Q$ into $step(C,Q)$ by adding the image of the existential part of $C$:
\begin{normalsize}
\begin{eqnarray*}
step(C,Q) & := & \FOR \overrightarrow{(v \IN V)} \ \overrightarrow{(y \IN Y)} \\
 & & \WHERE  O(\overrightarrow{v}) \wedge B(\overrightarrow{h(x)}, \overrightarrow{y}) 
\\ 
 & & \RETURN R(\overrightarrow{v})
\end{eqnarray*}
\end{normalsize}
Chase steps are semantics-preserving on instances that obey the constraints~\cite{Popa99anequational}:
$$C \vdash Q \cong step(C,Q)$$
The {\it chase} itself is to repeatedly (and non-deterministically) choose a homomorphism and step until a fixed point (up to homomorphic equivalence) is reached:
$$
Q \rightsquigarrow step(C, Q) \rightsquigarrow step(C, step(C, Q)) \rightsquigarrow \ldots 
$$
%The termination condition is to not take a chase step when there is a homomorphism extending $h$ from $chase(Q, C)$ to $Q$.
Termination of the chase is undecidable, but if it terminates the final result is unique (up to homomorphic equivalence)~\cite{Deutsch:2006:QRC:1121995.1122010}.  Provided certain fairness conditions are met~\cite{Deutsch:2006:QRC:1121995.1122010}, the chase extends easily to sets of EDs by choosing a particular ED to chase with at each step.  A key theorem about the chase is that it reduces the question of query equivalence under constraints to simple homomorphic equivalence: let $C$ be a set of EDs and $Q_1, Q_2$ queries.  Then:
$$
C \vdash Q_1 \cong Q_2 \ \ \ \  \textnormal{iff} \ \ \ \ chase(C,Q_1) \leftrightarrow chase(C, Q_2)
$$
{\bf Example.} Continuing with our $Movies$ example, there is a homomorphism $x \mapsto 
m_1, y \mapsto m_2$ from the front of our constraint: 
\begin{normalsize}
\begin{eqnarray*}
C& := & \FORALL (x \IN Movies) \ (y \IN Movies) \\
& & \WHERE x.{\sf title} = y.{\sf title}, \\ 
& & \EXISTS \\
& & \WHERE x.{\sf director} = y.{\sf director}
\end{eqnarray*}
\end{normalsize}
to our original query:
\begin{normalsize}
\begin{eqnarray*}
Q_1 & := & \FOR (m_1 \IN Movies) \ (m_2 \IN Movies) \\
 & & \WHERE m_1.{\sf title} = m_2.{\sf title} \\
 & & \RETURN (m_1.{\sf director}, m_2.{\sf actor})
\end{eqnarray*}
\end{normalsize}
Hence, we can take a chase step: 
\begin{normalsize}
\begin{eqnarray*}
step(C, Q_1) := & & \FOR (m_1 \IN Movies) \ (m_2 \IN Movies) \\
 & & \WHERE m_1.{\sf title} = m_2.{\sf title} \wedge \\
 & & \ \ \ \ \ \ \ \ \ \ \ \  m_1.{\sf director} = m_2.{\sf 
director} \\
 & & \RETURN (m_1.{\sf director}, m_2.{\sf actor})
\end{eqnarray*}
\end{normalsize}
At this point we stop chasing, because $step(C, step(C, Q_1))$ is syntactically equal (and hence homomorphically equivalent) to $step(C, Q_1)$, and we have established that $C \vdash Q_1 \cong chase(C, Q_1)$. %In general, it is not enough to check for the syntactic equality of $chase(Q, C)$ and $Q$ to stop the chase, as queries can be equivalent without being syntactically equal.  Hence, we must use homomorphisms to detect termination.  

\section{Tableaux Minimization}
\label{sec:minimize}

We now demonstrate how to minimize queries in the presence of 
EDs, a technique known as ``tableaux minimization using chase and back-chase''~\cite{Deutsch:2006:QRC:1121995.1122010}.   Suppose we are given a query $Q$ and set of EDs $C$.  
We first chase $Q$ with $C$ to obtain $U$, a so-called {\it universal plan}.  We then 
search for subqueries of $U$ (which are intuitively obtained by removing generators from $U$), chasing each in turn with $C$ to check for equivalence with $U$.  There will always be a unique minimal query (up to homomorphic equivalence)~\cite{Deutsch:2006:QRC:1121995.1122010}.

\subsection*{Example - Movies}
Start with our query and constraint from the introduction:
\begin{normalsize}
\begin{eqnarray*}
Q_1 & := & \FOR (m_1 \IN Movies) \ (m_2 \IN Movies) \\
 & & \WHERE m_1.{\sf title} = m_2.{\sf title} \\
 & & \RETURN (m_1.{\sf director}, m_2.{\sf actor})
\end{eqnarray*}        
\begin{eqnarray*}
C & := & \FORALL (x \IN Movies) \ (y \IN Movies) \\
& & \WHERE x.{\sf title} = y.{\sf title} \\ 
& & \EXISTS \\
& & \WHERE x.{\sf director} = y.{\sf director}
\end{eqnarray*}
\end{normalsize}
The universal plan, i.e., $chase(C,Q_1)$, is:
\begin{normalsize}
\begin{eqnarray*}
U & := & \FOR (m_1 \IN Movies) \ (m_2 \IN Movies) \\
 & & \WHERE m_1.{\sf title} = m_2.{\sf title} \wedge m_1.{\sf director} = m_2.{\sf 
director} \\
 & & \RETURN (m_1.{\sf director}, m_2.{\sf actor})
\end{eqnarray*}        
\end{normalsize}
We proceed with tableau minimization by searching for subqueries of $U$.  
Removing the generator $(m_1 \IN Movies)$ and replacing $m_1$ with $m_2$ in the body of $Q$ gives a smaller query:
\begin{normalsize}
\begin{eqnarray*}
Q_2 & := & \FOR (m_2 \IN Movies) \\
 & & \RETURN (m_2.{\sf director}, m_2.{\sf actor})
\end{eqnarray*}        
\end{normalsize}
We wish to check that $C \vdash Q_1 \cong Q_2$, so we check that $U = chase(C,Q_1) \leftrightarrow chase(C, Q_2)$.  We find that $chase(C, Q_2) \cong Q_2$, so we will actually check that  $U \leftrightarrow Q_2$.  The identity substitution is a homomorphism $Q_2 \to U$: the important part to notice is the $\RETURN$ clause, wherein $(m_2.{\sf director},$ $m_2.{\sf actor})$ is equal to $(m_1.{\sf director},$ $m_2.{\sf actor})$ precisely because 
of the equality $m_1.{\sf director}$ $=$ $m_2.{\sf director}$, which appears in $U$ 
but not in $Q_1$.  There is also a homomorphism $U \to Q_2$, namely, $m_2 
\mapsto m, m_1 \mapsto m$.  We thus conclude that $C \vdash U \cong Q_2 \cong Q_1$. 
\newpage
\subsection*{Example - Indexing}

As we remarked in the introduction, a reasonably competent programmer might be able to optimize our $Movies$ query directly, without applying the chase at all.  But sometimes constraints are not available to the programmer, such as when indices are generated dynamically.  Consider the following query, which returns the names of all $People$ between 16 and 18 years old:
\begin{normalsize}
\begin{eqnarray*}
Q_1 & := & \FOR (p \IN People) \\
 & & \WHERE p.{\sf age} > 16 \wedge p.{\sf age} < 18 \\
 & & \RETURN p.{\sf name}
\end{eqnarray*}   
\end{normalsize}
Technically, this query is not a purely conjunctive query because the where clause involves the less-than predicate $<$.  However, the machinery of tableaux minimization can still be used, and one of the advantages of our Coq development is that users are free to write arbitrary Coq expressions in where clauses, and Coq tactics can be used to reason about such where clauses.
  
Depending on the underlying access patterns, or the whims of a database administrator, an RDBMS might transparently index $People$ by creating another relation $Children$, such that the following two constraints hold:
\begin{normalsize}
\begin{eqnarray*}
C_1 & := & \FORALL (p \IN People) \\
 & & \WHERE p.{\sf age} < 21 \\
 & & \EXISTS (c \IN Children) \\
 & & \WHERE p.{\sf name} = c.{\sf name} \wedge p.{\sf age} = c.{\sf age}  \\
 & & \\
  C_2 & := & \FORALL (c \IN Children) \\
  & & \WHERE \\
 & & \EXISTS (p \IN Person) \\
 & & \WHERE p.{\sf name} = c.{\sf name} \wedge p.{\sf age} = c.{\sf age}
\end{eqnarray*}       
\end{normalsize}

In order to use this new index queries written against $People$ must be rewritten, at runtime, to use $Children$.  Tableaux minimization provides an automated mechanism to do so. 

Let $C = \{ C_1, C_2\}$.  First, we find the universal plan $U = chase(C, Q_1)$.  We begin by chase stepping $Q$ with $C_1$.  The identity substitution is a homomorphism $front(C_1) \to Q_1$, because $p.{\sf age} < 21$ is entailed by $p.{\sf age} > 16 \wedge p.{\sf age} < 18$; thus we chase step to:
\begin{normalsize}
\begin{eqnarray*}
U & := & \FOR (p \IN People) \ (c \IN Children) \\
 & & \WHERE p.{\sf age} > 16 \wedge p.{\sf age} < 18 \wedge \\
 & & \ \ \ \ \ \ \ \ \ \ \ \ p.{\sf name} = c.{\sf name} \wedge p.{\sf age} = c.{\sf age} \\
 & & \RETURN p.{\sf name}
\end{eqnarray*}  
\end{normalsize}
and we find that $U \cong step(C_1, U)$, so no further chase steps using $C_1$ are possible.  Now we chase step $U$ using $C_2$, and we find that $U \cong step(C_2, U)$, so no further chase steps with $C_2$ are possible.  Hence we have computed the universal plan $U = chase(C,Q_1)$.

Next, we minimize the universal plan by removing the $(p \IN People)$ generator (note that to do so we must replace each occurrence of $p$ with some other well-typed variable, in this case $c$):
\begin{normalsize}
\begin{eqnarray*}
Q_2 & := & \FOR (c \IN Children) \\
 & & \WHERE c.{\sf age} > 16 \wedge c.{\sf age} < 18 \\
  & & \RETURN c.{\sf name}
\end{eqnarray*}  
\end{normalsize}
We now ``back-chase'' $Q_2$ with $C$.  We can take no chase steps with $C_1$, because there is no substitution $h$ that makes $(h(p) \IN People)$ equal to $(c \IN Children)$.  We can chase step with $C_2$ using the identity substitution to obtain:
\begin{normalsize}
\begin{eqnarray*}
Q_2' & := & \FOR (c \IN Children) \ (p \IN Person) \\
 & & \WHERE c.{\sf age} > 16 \wedge c.{\sf age} < 18 \wedge \\
 & & \ \ \ \ \ \ \ \ \ \ \ \   p.{\sf name} = c.{\sf name} \wedge p.{\sf age} = c.{\sf age}\\
  & & \RETURN c.{\sf name}
\end{eqnarray*}  
\end{normalsize}
and no further steps with $C_1$ or $C_2$ are possible. Hence we have computed $Q_2' = chase(C, Q_2)$.  Recall that our goal is to check that $C \vdash Q_1 \cong Q_2$, which we do by checking $U = chase(C, Q_1) \leftrightarrow chase(C, Q_2) = Q_2'$; i.e., by checking $U \leftrightarrow Q_2'$.  It's easy to see that $U$ and $Q_2'$ are homomorphically equivalent under the substitution $p \mapsto c, c \mapsto p$, and we are finished.   

%
%We check that $C \vdash Q^\prime \cong U$ by checking $chase(C, Q') \leftrightarrow U = chase(C,Q)$.  We start by finding $chase(C, Q')$, which turns out to be $Q'$ because no chase steps can be taken: there is no substitution $h$ that makes $(h(p) \IN People)$ equal to $(c \IN Children)$.  By the same reasoning there is no homomorphism $U \to Q^\prime$, and hence $C$ $\nvdash$ $Q^\prime \cong U$.  Indeed, there may be extra tuples in $Children$ that do not appear in $People$.  
%
%Fortunately, if our index was built correctly we know that an additional constraint holds:
%\begin{normalsize}
%\begin{eqnarray*}
%\end{eqnarray*}     
%\end{normalsize}
%As such, we may chase $Q^\prime$ with $C^\prime$ (using the identity substitution) to obtain the equivalent (under $C'$):
%\begin{normalsize}
%\begin{eqnarray*}
%Q^{\prime\prime} & := & \FOR (c \IN Children) \ (p \IN Person) \\
% & & \WHERE c.{\sf age} > 16 \wedge c.{\sf age} < 18 \wedge \\
% & & \ \ \ \ \ \ \ \ \ \ \ \   p.{\sf name} = c.{\sf name} \wedge p.{\sf age} = c.{\sf age}\\
%  & & \RETURN c.{\sf name}
%\end{eqnarray*}  
%\end{normalsize}
%Now we can see that the identity substitution is a homomorphism $Q^{\prime\prime} \leftrightarrow U$ (owing to the fact that $p.{\sf name} = c.{\sf name}$ and $p.{\sf age} = c.{\sf age}$), and since $chase(C',U) \cong U$, we know that $C, C' \vdash Q^{\prime\prime} \cong U$.  We established earlier that $C \vdash U \cong Q$ and that $C' \vdash Q'' \cong Q'$.  These facts allow us to conclude that $C, C' \vdash U \cong Q \cong Q' \cong Q''$.

\section{Coq Development - Overview}

We now discuss how we use Coq to optimize queries.
For expository purposes, we demonstrate the techniques using the movie example from section~\ref{sec:tableaux-minimization}.
We can express the movie query in Gallina with the following code:
\begin{coq}
Def q : M (string * string) :=
  m1 <- Movies ; m2 <- Movies ;
  guard (m1.(title) = m2.(title)) ;
  return (m1.(director), m2.(actor)).
\end{coq}
Here, \coqe{q} is the name of the query.
To the right of the colon is the query's type, i.e. \coqe{M (string * string)} represents a relation (\coqe{M}) that contains values which are pairs of strings.

The syntax draws its inspiration from Haskell's syntax for monadic computations.
\coqe{<-} intuitively means \FOR, \coqe{guard} means \WHERE, and \coqe{return} means \RETURN.
Note that while this query follows exactly the form prescribed by SQL, not all raw queries will strictly follow this form.
For example, if we wish to re-focus the above query on the movie ``Lord of the Rings'' we could introduce an additional guard condition after ``binding'' \coqe{m1}.
\begin{coq}
Definition q_LOR : M (string * string) :=
  m1 <- Movies ;
  guard (m1.(title) = ``Lord of the Rings'') ;
  m2 <- Movies ;
  guard (m1.(title) = m2.(title)) ;
  return (m1.(director), m2.(actor)).
\end{coq}
While this flexible syntax may make it easier to structure large queries, there are other benefits to it that we will see in Section~\ref{sec:low-level}.

The focus of our work is on query optimization.
Given the above query, we can ask Coq to optimize it using the following code.
\begin{coq}
Definition optimized_query
: { q$_{opt}$ : M (string * string) | title_director_ed $\vdash$ q$_{opt}$ = q }.
optimize.
Defined.
\end{coq}
Again the first line declares the name of a term.
Now, the the right of the colon we have a more interesting type, noteably a dependent one.
This syntax represents a dependent pair of a query (\coqe{q$_{opt}$}) of type \coqe{M (string * string)} and a proof of the proposition to the right of the vertical bar.
Namely, this proof carries around a witness that under the assumption that the \coqe{title_director_ed} is provable about the database, the meaning of \coqe{q$_{opt}$} is the same as the meaning of \coqe{q}.
Since we with Coq to fill in this value for us, we end the definition with a period and use the ``tactic'' \coqe{optimize} to discharge fill in the appropriate value.
The keyword \coqe{Defined} signals the end of the definition since \coqe{optimize} completely fills in the term.

We can look at the result of the optimization by asking Coq to print the first component of the pair.
\begin{coq}
Eval ... in (proj1_sig optimized_query).
(* = x <- Movies ; return (x.(director), x.(actor))
 *   : M (string * string)
 *)
\end{coq}
Here, ``...'' elide the reduction strategy which tells Coq which symbols to keep abstract during reduction and the \coqe{proj1_sig} simply forgets the proof component.

\paragraph{Querying in Coq} While not necessarily a proxy for a real database, all of the queries are executable within Coq (our implementation uses an implementation of relations as lists which are quotiented to act as sets).
Even on small examples (5 rows), the optimized implementation performs 2x faster than the non-optimized version.
While a production database would likely do considerably faster (on considerably larger relations) it should be noted that the semantic optimization that we achieve in this example enables us to reduce the asymptotic running time \emph{in a fully verified way}.

\subsection{Background: Tactic-based Programming}

The ``standard'' approach to developing an algorithm such as the chase in Coq would be to program it in Gallina, Coq's total, functional programming language.
By the Curry-Howard correspondence~\cite{} this programming language is also a logic where propositions are types and programs are proofs.
A more complete description of the correspondence can be found in a variety of sources~\cite{}.
We will return to this approach in more detail in Section~\ref{sec:??}, in this work we develop our optimization in a different way.

In addition to Gallina, Coq also comes with another programming language, \ltac.
Unlike Gallina, which is strongly-typed and pure, \ltac\ is untyped and partial.
\ltac\ is a proof scripting language that is used to construct proof terms in an imperative style.
In this section we will discuss the key aspects of \ltac\ using a simple example for implementing addition.
\ltac\ is centered around manipulating Gallina terms.


The most common use of \ltac\ is to construct proofs of Gallina propositions.
For example, proving that \coqe{x + y = y + x} can be done by using the Gallina theorem that proves the commutativity of addition, i.e.
\begin{coq}
Theorem plus_comm : forall (n m : nat), n + m = m + n.
Proof. ... Qed.
\end{coq}
In \ltac{} we can apply this theorem using the \coqe{apply} tactic.
\begin{coq}
(* x, y : nat
 * ==============
 * x + y = y + x
 *)
apply plus_comm. (* => goal solved *)
\end{coq}
The implementation of \coqe{apply} unifies \coqe{x + y = y + x} with \coqe{?n + ?m = ?m + ?n} where the question mark variables (e.g. \coqe{?n}) are flexible unification variables that the unification can pick values for.
To solve this problem, the unification algorithm picks \coqe{?n $\mapsto$ x} and \coqe{?m $\mapsto$ y}.

In addition to \coqe{apply}, \ltac{} also provides \coqe{rewrite} to perform rewriting by user-defined relations.
Rewriting can be considerably more flexible than direct function application but works in much the same way.
Generalizing the goal above to \coqe{(x + y) * 3 = (y + x) * 3} makes \coqe{plus_comm} no longer immediately apply, but since equality is a transitive relation we can use \ltac{} to rewrite in the conclusion and then solve the goal by the reflexivity of equality.
\begin{coq}
(* x, y : nat
 * ==============
 * (x + y) * 3 = (y + x) * 3
 *)
rewrite plus_comm.
(* x, y : nat
 * ==============
 * (y + x) * 3 = (y + x) * 3
 *)
reflexivity. (* => goal solved *)
\end{coq}

In addition to solving concrete goals such as the ones above, \ltac{} is also able to manipulate unification variables directly.
Take the goal \coqe{?x = 3} for example.
The \coqe{reflexivity} tactic will solve this goal by instantiating \coqe{?x} with the value 3.
These unification variables are commonly used when proving existential quantifiers.
For example, in the following goal we use \coqe{eexists} to introduce a new unification varible for \coqe{x} and then solve the resulting equation with \coqe{reflexivity}.
\begin{coq}
(* ==================
 * exists x : nat , x = 3
 *)
$\texttt{\textcolor{dkblue}{eexists}}$.
(* ==================
 * ?x = 3
 *)
reflexivity. (* => goal solved *)
\end{coq}

\greg{this is a very unfocused section}

\subsection{Normalization}
\label{sec:normalization}

The first phase of our optimization pipeline normalizes queries into the \FOR...\WHERE...\RETURN structure presented in Section~\ref{sec:queries}.
In Coq, we can define this structure as a function that takes the three pieces of the query and stitches them together into the full query.
The definition is the following:
\begin{coq}
Definition query {S T: Type}
  (P : M S) (C : S -> bool) (E : S -> T) : M T :=
  Mbind P (fun x => Mguard (C x) (Mret (E x))).
\end{coq}
Here, \coqe{P} represents the \FOR-clause which generates the tableau,
\coqe{C} represents the conditional \WHERE-clause, and \coqe{E} represents the \RETURN-clause.
In our representation, we use \coqe{Mplus} to construct a relational cross-product of two ``binds.''
Thus, the normalized form of our movies query is the following:
\begin{coq}
query (Mplus Movies Movies)
      (fun x => (fst x).(title) ?[=] (snd x).(title))
      (fun x => ((fst x).(director), (snd x).(actor)))
\end{coq}

In addition to generating this term, in order to fit into our fully-verified pipeline we must also guarantee that the transformation yields an equivalent query.
Within our shallow encoding we can perform this normalization by incrementally applying proven theorems that witness the soundness of individual transformations.

The process begins by asking Coq to generate a unification variable representing the final answer and using it to witness the answer.
We are then left to solve the goal \coqe{Meq ?1 q}, which we solve using a set of theorems crafted to specifically match on goals of this form.
\begin{coq}
Theorem prep_for_normal : forall {T} (q q' : M T),
  Meq q' (Mbind (query (Mret tt) (fun _ => true) (fun x => x))
                       (fun _ => q)) ->
  Meq q' q.
Proof. ... Qed.
\end{coq}
When applied to the initial goal, the first theorem (\coqe{prep_for_normal}), produces a new goal where the right-hand-side of the equivalence now binds the empty query and then returns \coqe{q}.

While not particularly insightful from a proof-theoretic point of view, this lays the groundwork for the remaining theorems to move components of \coqe{q} into the query.
For example, \coqe{normal_pull_plus} moves a bind into the query.
\begin{coq}
Lemma normal_pull_plus
: forall {T U V W : Type} (qb : M T) (qg : T -> bool) (qr : T -> U) x (y : _ -> _ -> M V),
  Meq q'
      (Mbind (query (Mplus qb x) (fun x => qg (fst x)) (fun x => (qr (fst x), snd x)))
             (fun val : U * W => y (fst val) (snd val))).
  Meq q'
      (Mbind (query qb qg qr)
             (fun val : U => Mbind x (y val))).
Proof. ... Qed.
\end{coq}
Concretely, applying \coqe{normal_pull_plus} to the goal produced by \coqe{prep_for_normal} produces a new goal that has shrunk the size of the query to normalize (by ``removing'' a bind) and placing it in the \FOR-clause of the \coqe{query} definition.
\begin{coq}
show the goal?
\end{coq}
\greg{should I present these are rewriting lemmas instead? that is what they are in the actual code}

The normalization process also includes lemmas for pulling \WHERE- and \RETURN-clauses.
To handle nested structures such as \coqe{x <- (y <- Movies ; return y) ; return x} we preface the normalization step by rewriting with lemmas which flatten the query.
For example \coqe{Mbind_assoc} (shown below) will convert the nested query above into \coqe{y <- Movies ; x <- return y ; return x}.
\begin{coq}
Lemma Mbind_assoc
: forall (A B C : Type) (c1 : M A) (c2 : A -> M B)
         (c3 : B -> M C),
  Meq (Mbind (Mbind c1 c2) c3)
      (Mbind c1 (fun x : A => Mbind (c2 x) c3))
\end{coq}

The main benefit (which we will see throughout the pipeline) is the ability to easily extend the transformations simply by proving relatively simple lemmas such as the ones above.
For example, the above \coqe{normal_pull_plus} is not sufficient to handle nested queries where \coqe{x} could depend on the values that were previously bound.
Normally, supporting this type of term manipulation would be quite painful since we would need to track the number of binders that we are under or generate fresh names.
Instead, we can foist all of that complexity back onto Coq by phrasing the appropriate lemma and using Coq's higher-order unification to solve the problem for us.
Using this technique, the generalization of \coqe{normal_pull_plus} to handle nested relations would be the following:
\begin{coq}
Lemma normal_pull_dplus_ret_id
: forall {T U V W : Type} (qb : M T) qg x (y : _ -> _ -> M V),
  Meq (Mbind (query qb qg (fun x => x))
             (fun val : T => Mbind (x val) (y val)))
      (Mbind (query (Mdplus qb x) (fun x => qg (fst x)) (fun x => (fst x, snd x)))
             (fun val : T * W => y (fst val) (snd val))).
Proof. ... Qed.
\end{coq}

The final result of normalization for the movies query is exactly the query presented in Section~\ref{sec:example}.
In our syntax:
\begin{coq}
query (Mplus Movies Movies)
      (fun x => (fst x).(title) ?[=] (snd x).(title))
      (fun x => ((fst x).(director), (snd x).(actor)))
\end{coq}

\subsection{The Chase}

With a normalized query in hand, we begin chasing it using our embedded dependencies.
The general approach is similar to that of normalization, we will use a ``prepping'' lemma to set up the goal into a form that we can automate and then use stepping lemmas to solve the goal one step at a time.

\paragraph{Representing Embedded Dependencies}
We first express the representation of embedded dependencies.
Our definition is the standard one given in Section~\ref{sec:embedded-dependencies} and is encoded in the same way that we encode queries.
\begin{coq}
Definition embedded_dependency {S S': Type}
  (F : M S) (Gf : S -> bool) (B : M S') (Gb : S -> S' -> bool) :=
  Meq (query F Gf (fun x => x))
      (query (Mbind F (fun x => Mbind B (fun y => Mret (x,y))))
             (fun ab => Gf (fst ab) && Gb (fst ab) (snd ab))
             (fun x => fst x)).
\end{coq}

%% With an executable data model (e.g. finite sets) over queries with decidable equality on their return types, it is simple to prove that embedded dependencies hold for particular concrete databases.



\paragraph{Backtracking to Find a Morphism}
With a representation of embedded dependencies in hand, first part of the chase step is to find a tableau homomorphism from the query to the front of the embedded dependency.
This step is inherently more complex than normalization because it involves a backtracking search.
Fundamentally, however, the approach is the same as for normalization.

In the explanation of the chase step in Section~\ref{sec:chase} the morphism was from the variables bound in the \FOR-clause to the variables bound in the front of the embedded dependency.
In our movie query example we are looking for a mapping that assigns values in $\{x,y\}$ to values in $\{m_1,m_2\}$.

Since our queries are simply Coq terms, referencing these binders explicitly can be quite difficult, and, as we will see later, is not very extensible.
Rather, we will encode our morphism as a function between the types being bound.
In this example, the type of the \FOR-clause of the query is \coqe{Movie * Movie} and the type of the \FORALL-clause is also \coqe{Movie * Movie}, so we are looking for a function \coqe{h : Movie * Movie -> Movie * Movie}.
Looking at the query and the ED, there are 4 reasonable choices.
\begin{coq}
h x = (fst x, fst x)
h x = (fst x, snd x)
h x = (snd x, fst x)
h x = (snd x, snd x)
\end{coq}
Where \coqe{fst} is extracting the first element of the pair and \coqe{snd} is extracting the second element of the pair.

As before, we are going to construct these functions incrementally using particular theorems that represent individual steps of reasoning.
Ultimately, our algorithm considers each value bound in the query and maps to to a value bound from the ED.
We encode this process using the following lemmas:
\begin{coq}
Lemma pick_split
: forall {T U U' : Type} (m : M T) (u : M U) (u' : M U') f g,
  Mimpl (Mmap f m) u ->
  Mimpl (Mmap g m) u' ->
  Mimpl (Mmap (fun x => (f x, g x)) m) (Mplus u u').
Proof. ... Qed.

Lemma pick_left {T' U' V} (f' : _ -> V) (x : M V) (y : M T') (k' : M U')
: Mimpl (Mmap f' k') x ->
  Mimpl (Mmap (fun x => f' (fst x)) (Mplus k' y)) x.
Proof. ... Qed.

Lemma pick_right {T' U' V} (f' : _ -> V) (x : M V) (y : M T') (k' : M U')
: Mimpl (Mmap f' k') x ->
  Mimpl (Mmap (fun x => f' (snd x)) (Mplus y k')) x.
Proof. ... Qed.

Lemma pick_here {T} (x : M T)
: Mimpl (Mmap (fun x => x) x) x.
Proof. ... Qed.
\end{coq}
The first theorem (\coqe{pick_split}) finds a morphism from \coqe{Z} to \coqe{Mplus x y} by combining a morphism from \coqe{Z} to \coqe{x} with another morphism from \coqe{Z} to \coqe{y}.
\coqe{pick_left} decides to use only the left-hand side of the \coqe{Mplus k' y} to determine \coqe{x}, \coqe{pick_right} is analagous for the right-hand side.
Finally, \coqe{pick_here} applies when the value being searched for is exactly the value being bound in which case it can pick the value directly.

We combine these proofs into into a search using \ltac's backtracking \coqe{+} operator.
The core of the procedure is the following:
\begin{coq}
Ltac find_bind_morphism :=
  lazymatch goal with
  | |- Mimpl (Mmap _ _) (Mplus _ _) =>
      (eapply pick_split)
  | |- Mimpl _ _  =>
      (simple eapply pick_here)
    + (simple eapply pick_left)
    + (simple eapply pick_right)
  end ; find_bind_morphism.
\end{coq}
Applied to our simple example this essentially amounts to:
\begin{coq}
eapply pick_split ;
  (simple eapply pick_here + simple eapply pick_left + simple eapply pick_right) ;
  (simple eapply pick_here + simple eapply pick_left + simple eapply pick_right)
\end{coq}
The first application splits the morphism into two parts, and the semi-colon runs the remainder of the tactic on the two independent goals.
The plus operator effectively allows choices to be made independently and allows backtracking to encode the non-deterministic choice.
In this case, along the first goal we \coqe{pick_left} and then \coqe{pick_here} and along the second we \coqe{pick_right} and then \coqe{pick_here}.
The search completes with each of the four candidate morphisms written above, the next step is to solve the side conditions.

\paragraph{Solving the Side-conditions}
With a candidate morphism in hand, the next step is to discharge the side condition which guarantees that the \WHERE-clause of the query implies the \WHERE-clause of the embedded dependency.
In our problem, this amounts to the following:
\begin{coq}
forall x : S, (fst x).(title) ?[=] (snd x).(title) = true
     -> (fst (h x)).(title) ?[=] (snd (h x)).(title)
\end{coq}
However, once we get to this step, \coqe{h} is exactly one of the morphisms constructed by the previous step.
When we plug in the correct morphism, i.e. \coqe{h x = (fst x, snd x)} (recall that we are enumerating all of the potential morphisms) we get the following:
\begin{coq}
forall x : S, (fst x).(title) ?[=] (snd x).(title) = true
     -> (fst x).(title) ?[=] (snd x).(title) = true
\end{coq}
While this goal is trivially true, in general these side conditions can require potentially arbitrary reasoning.
For example, in the indexing example, proving this implication requires proving the following arithmetic fact.
\begin{coq}
forall p, p.age ?[>] 16 && p.age ?[<] 18 = true ->
          p.age ?[<] 21 = true
\end{coq}
Coq already has the \coqe{omega} tactic for performing arithmetic reasoning.
In addition, we can develop our own theorems and \ltac{} for automating different domains, for example the length of strings, the case of characters, or even complex arithmetic on floating point numbers.

\greg{The automation used here is a parameter to the tactic}

\paragraph{Ensuring Progress}
After the side-condition is checked, the final piece is to ensure that this chase step makes interesting progress by adding \emph{new} facts or data to the query.
This check simply requires that we have a tactic that can find an isomorphism between queries, which is essentially the same as what we have done up until this point, except that we also need to prove that the \RETURN-clauses of the two queries are equal under the assumptions in the \WHERE-clause.
The \ltac{} to check this is trivial given the machinery that we developed in the previous two steps.
The entire \ltac{} is (essentially) the following:
\begin{coq}
Ltac prove_query_morphism solver :=
  eapply check_query_morphism_apply ;
    [ find_bind_morphism
    | simpl ; solve [ solver ]
    | simpl ; solve [ solver ] ]).

Ltac prove_query_isomorphism solver :=
  split; prove_query_morphism solver
\end{coq}


\greg{Note that we are removing some of the complexity from the tactics.}


\paragraph{Traversing EDs}

\greg{This section should go at the beginning of the chase section}

The previous sections have shown how to chase a single embedded dependency, chasing a collection of EDs is not much more difficult.
Embedded dependencies are communicated via premises on the entailment, so all that remains is to non-deterministically select the appropriate ED.
The approach here is the same as when we non-deterministically found the morphism; we simply perform an exhaustive backtracking search trying to chase each one until we succeed.
For convenience we require that multiple EDs are combined with $\wedge$.

\subsection{Minimization}

The final step in optimization is to remove extraneous binds from the query.
By now, the techniques are all old-hat.
We will use incremental lemmas to iterate through the binders and attempt to drop each one by expressing a side-condition the expresses that the information in that binder can be reconstructed from the other bound values.
The core relevant lemmas are the following:
\begin{coq}
Lemma minimize_drop
: forall {T T' V : Type} (qb : M T) (qb' : M T') qg (qr : _ -> V) f (qb'' : M T') qg'',
  Mimpl (Mmap f qb') qb ->
  Meq (query (Mplus qb qb') qg qr)
      (query qb' (fun y => qg (f y,y)) (fun y => qr (f y,y))) ->
  Meq (query qb' (fun y => qg (f y,y)) (fun y => qr (f y,y)))
      (query qb'' (fun y => qg'' (f y,y)) (fun y => qr (f y,y))) ->
  Meq (query (Mplus qb qb') qg qr)
      (query (Mmap (fun x => (f x, x)) qb'') qg'' qr).
Proof. ... Qed.

Lemma minimize_keep
: forall {T T' V : Type} (qb : M T) (qb' : M T') qg (qr : _ -> V) (qb'' : M T') qg'',
  (forall x : T,
     Meq (query qb' (fun y => qg (x,y)) (fun y => qr (x,y)))
         (query qb'' (fun y => qg'' (x,y)) (fun y => qr (x,y)))) ->
  Meq (query (Mplus qb qb') qg qr)
      (query (Mplus qb qb'') qg'' qr).
Proof. ... Qed.
\end{coq}
\coqe{minimize_drop} states that we can drop the first (left) binder if we can find a way to compute it (\coqe{f}) from the right binder, i.e. a morphism from \coqe{Mmap f qb'} to \coqe{qb}.
The second premise, ensures that this choice of \coqe{f} respects the equivalence of the query.
\coqe{minimize_keep} is the fallback case.
If we can not find a way to construct the information from the rest of the query, then we must keep this information, but we can still optimize the rest of the query (represented by quantifying over any value from the relation and ensuring that the rest of the query is still valid).

\greg{Note, this is a bit incomplete because the current automation does not allow backwards minimization}

\subsection{Scheduling}
\greg{not finished but could be interesting and relatively simple}

\section{Discussion}

Performance evaluation (how long does it take to optimize)

\subsection{Reflective Implementation}

\subsection{Related \& Future Work}
Fiat~\cite{deleware2015fiat}

Chase in Coq~\cite{}

MirrorCore~\cite{malecha2014thesis}

computational reflection~\cite{}

\section{Conclusions}




{\bf Acknowledgement.}  The authors would like to thank Lucian Popa for answering many questions about semantic optimization.

\bibliographystyle{plain}
\bibliography{thesisbib}

\end{document}
